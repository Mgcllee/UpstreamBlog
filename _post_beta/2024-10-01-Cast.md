---
title:  "[C++] 형변환 연산자 정리"
excerpt: ""

categories: [Language, C&#47;C&#43;&#43;]
tags: [C&#47;C&#43;&#43;]

toc: true
toc_sticky: true
 
date: 2024-10-01
last_modified_at: 2024-10-01
---

자료형을 변환할 때, C 언어는 **암시적 형변환과 명시적 형변환** 2가지가 존재합니다.  
간략하게 설명하면 암시적 형변환은 컴파일러가 대신 수행하는 형변환이고  
명시적 형변환은 반대로 프로그래머가 직접 형변환을 수행하는 것입니다.  

```c++
int i_num = 3.14;                   // 암시적

double d_num_01 = double(i_num);    // 명시적
double d_num_02 = (double)i_num;    // 명시적
```

그렇다면 C++ 는 형 변환 연산자가 무엇이 있을까요?  
C++ 에서 사용하는 형변환 연산자는 아래의 4가지가 있으며 모두 다른 역할을 수행합니다.  

```c++
const_cast<data_type>(Data);
dynamic_cast<data_type>(Data);
reinterpret_cast<data_type>(Data);
static_cast<data_type>(Data);
```

<br/>
<br/>

# static_cast
---



<br/>
<br/>

# const_cast 
---

const_cast를 사용하기 전 const가 무엇인지 정리하고 소개하겠습니다.  
const는 ‘ **불변 상수** ’ 를 의미합니다. 또한 선언과 동시에 초기화 해야 합니다.  
const를 포인터와 함께 사용하면 포인터 자체 혹은 대상에 불변 성질을 부여할 수 있습니다.  

```c++
int num_01 = 1;
int num_02 = 2;

// const (int*)와 의미가 같다.
const int* ptr_01 = &num_01;

// [Compile Error] : 'ptr_01'의 대상은 불변. (가르키는 메모리 변경 불가)
*ptr_01 = 10; 

// [Success] : num_01 자체가 const 속성을 갖는 것이 아니기 때문에 가능
num_01 = 10;  


// 포인터 자체가 상수가 됨
int* const ptr_02 = &num_02;

// [Success]
*ptr_02 = 10; 

// [Compile Error] : 포인터 자체가 불변이므로 내용 변경 불가능
ptr_02 = &num_03; 
```

<aside>
💡 만약 ‘num_0N’ 데이터들이 const int로 선언되었을 경우, 포인터는 반드시 const int*가 되어야 합니다.  
</aside>

const는 멤버 함수에도 사용할 수 있습니다.  

```c++
class Student 
{
private:
    int grade = 0;

public:
    int getGrade() const
	{
		int temp = 1;
		temp += 1;

        // [Compile Error]
		// grade += 1;

		return temp + grade;
	}
};
```

멤버 함수를 상수화(const) 시킬 경우,  
해당 함수 내부에서는 "모든 멤버 변수를 상수화 시킨다. 단, 지역변수는 예외로 한다." 라는 규칙이 적용됩니다.  

따라서 Student::getGrade( ) 함수에서 temp라는 지역 변수는 값의 수정이 가능지만  
멤버 변수인 grade의 값을 수정할 경우 Compile Error가 발생합니다.  

C++에서는 상수화(const)된 데이터를 비상수화(non-const)로 변환해주는 것이 **const_cast** 입니다.  
단, 변환 대상이 포인터 혹은 참조형 데이터일 경우에만 사용할 수 있습니다.  

```cpp
const int* ptr_01 = new int(10);
int* ptr_02 = const_cast<int*>(ptr_01);

// [Success] : ptr_01를 비상수로 변환하였으므로 가능
*ptr_02 = 20;
```

> volatile을 non-volatile로 변환할 때 사용되기도 합니다.  

<br/>
<br/>

# dynamic_cast

---

dynamic_cast를 사용하기 위한 사전 지식인 **업캐스팅과 다운캐스팅**에 대해서 설명하겠습니다.  

```c++
class Car {}
class Bus : public Car {}

int main()
{
    Bus bus;

    // [업 캐스팅]: 파생(자식) 클래스의 객체를 기본(부모) 클래스의 객체처럼
    Car* pcar = &bus; 

    Car car;

    // [다운캐스팅]: 업 캐스팅의 반대
    Bus* pbus = (Bus*)&car;
}
```

파생 클래스의 포인터를 기본 클래스의 포인터로 변환하는 것을 업캐스팅  
기본 클래스의 포인터에서 파생 클래스의 포인터로 변환하는 것을 다운캐스팅이라고 합니다.  

업캐스팅, 다운캐스팅은 C++의 특징인 다형성을 이용해서 코드의 재사용률을 높이기 위해서입니다.  
여기서 dynamic_cast 는 **안전한 다운 캐스팅** 을 위해서 사용됩니다.  

<br/>
<br/>

# **reinterpret_cast**
---

reinterpret_cast 는 포인터/참조와 관련된 형변환만 지원합니다.

```c++
int* integer = new int(97);
char* character = reinterpret_cast<char*>(integer);

// 실행결과 : integer : 97 character : a
printf("integer : %d character : %c", *integer, *character);
```

단, 변환 대상에 상수값이 들어갈 수 없습니다.  
때문에 상수값을 전달하고 싶을 경우 ‘const_cast’를 사용해야 전달할 수 있습니다.  

<br/>
<br/>
