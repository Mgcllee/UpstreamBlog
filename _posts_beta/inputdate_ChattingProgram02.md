---
title:  "채팅 프로그램을 만들자 - 서버 구조 만들기"
excerpt: ""

categories: [Side Project, ChattingProgram]
tags: [SideProject, C&#47;C&#43;&#43;]

toc: true
toc_sticky: true
 
date: 2025-03-13
last_modified_at: 2025-03-13
---

> 포스트 **'채팅 프로그램을 만들자' 시리즈**에서는 프로젝트가  
> 어떤 의도로 설계 되었는지부터 서버 프로그램에서 IOCP를 1개가 아닌 여러 개를 사용하도록 변경한 이유까지  
> 프로젝트를 진행하면서 있었던 일들을 다룰 예정입니다.  

> 이전 포스트인 ["채팅 프로그램을 만들자 - 프로젝트 기본 설정하기"](https://mgcllee.github.io/posts/ChattingProgram01/)와 내용이 이어집니다.  

<br/>

## IOCP를 사용한 이유
---

단일 서버에 여러 클라이언트가 접속을 요청할 때, 서버의 물리적 성능과 소프트웨어적 성능에 따라 응답 속도에 차이가 있습니다.  

물리적 성능에 따른 응답 속도 차이는 다양한 하드웨어에 영향을 받지만 대표적인 것이 서버 CPU의 성능입니다.  
CPU의 연산 속도를 표시하는 클럭이 높을 수록 서버의 성능을 높일 수 있습니다.  
여기서 단순하게 클럭 속도를 매우 높여 서버의 성능도 함께 끌어올릴 수 없냐는 질문이 있을 수 있는데  
아쉽게도 이러한 방법에는 물리적 한계점이 존재하여 불가능합니다.  

> 물리적 한계점에 대해 자세히 알고 싶으시다면 [4GHz의 벽]() 이라는 이론을 찾아보세요.  
> 대략적인 내용은 클럭 속도에 따른 온도 상승으로 CPU에 문제가 생긴다는 것입니다.  
<br/>

4GHz의 벽을 만난 CPU 제조사들은 클럭 속도 향상 대신 연산을 수행하는 코어를 여러 개 사용하는 방법을 채택했습니다.  
이것이 멀티 코어의 시작입니다.  

<!-->아래의 내용이 IOCP를 사용한 이유와 연관이 있는지 고민...<-->
멀티 쓰레드는 반드시 멀티 코어에서만 실행되는 것이 아닙니다.  
쓰레드는 프로세스의 실행 흐름 단위로 단일 코어에서도 여러 쓰레드를 실행할 수 있습니다.  
대신 한 개의 코어를 여러 쓰레드가 함꼐 사용해야 하기 때문에  
멀티 코어보다 자주 문맥 전환이 발생할 것입니다.  



<!-->IOCP를 사용하지 않고 반복문으로만 처리한 경우, 속도 비교를 위한 측정자료 제시하기<-->

<br/>

## 한 메서드에서 모든 작업을 처리하는 나쁜 구조
---

<!-->위와 같은 골자로 비교를 위한 단일 IOCP 제시하기<-->

<br/>

## 작업을 분류하여 전담 처리 메서드 만들기
---

<!-->위와 같은 골자로 비교를 위한 복수 IOCP 제시하기<-->

<br/>

이번 포스트에서는 서버의 처리 성능을 높이기 위한 IOCP를 도입했지만  
채팅의 갱신 속도가 의도했던 만큼 빠르지 않았습니다.  

다음 포스트에서는 채팅 동기화 속도를 높이기 위해 시도했던 작업들과  
서버를 효율적으로 운영하기 위해 시도했던 작업들을 소개하겠습니다.  
